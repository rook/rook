# Default values for rook-cluster.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# Overrides Release Name if needed
# clusterNameOverride: rook

cluster:
  # the storage backend (only ceph is currently implemented)
  backend: ceph
  # The path on the host where configuration files will be persisted. If not specified, a kubernetes emptyDir will be created (not recommended).
  # Important: if you reinstall the cluster, make sure you delete this directory from each host or else the mons will fail to start on the new cluster.
  # In Minikube, the '/data' directory is configured to persist across reboots. Use "/data/rook" in Minikube environment.
  dataDirHostPath: /var/lib/rook
  # toggle to use hostNetwork
  hostNetwork: false
  # set the amount of mons to be started
  monCount: 3
# To control where various services will be scheduled by kubernetes, use the placement configuration sections below.
# The example under 'all' would have all services scheduled on kubernetes nodes labeled with 'role=storage' and
# tolerate taints with a key of 'storage-node'.
#  placement:
#    all:
#      nodeAffinity:
#        requiredDuringSchedulingIgnoredDuringExecution:
#          nodeSelectorTerms:
#          - matchExpressions:
#            - key: role
#              operator: In
#              values:
#              - storage-node
#      podAffinity:
#      podAntiAffinity:
#      tolerations:
#      - key: storage-node
#        operator: Exists
#    api:
#      nodeAffinity:
#      podAffinity:
#      podAntiAffinity:
#      tolerations:
#    mgr:
#      nodeAffinity:
#      podAffinity:
#      podAntiAffinity:
#      tolerations:
#    mon:
#      nodeAffinity:
#      tolerations:
#    osd:
#      nodeAffinity:
#      podAffinity:
#      podAntiAffinity:
#      tolerations:
#  resources:
#    api:
# The requests and limits set here, allow the api Pod to use half of one CPU core and 1 gigabyte of memory
#      limits:
#        cpu: "500m"
#        memory: "1024Mi"
#      requests:
#        cpu: "500m"
#        memory: "1024Mi"
# the above example requests/limits can also be added to the other components too
#    mgr:
#    mon:
#    osd:
  storage: # cluster level storage configuration and selection
    useAllNodes: true
    useAllDevices: false
#    deviceFilter:
#    metadataDevice:
#    location:
    storeConfig:
      storeType: bluestore
      databaseSizeMB: 1024 # this value can be removed for environments with normal sized disks (100 GB or larger)
      journalSizeMB: 1024  # this value can be removed for environments with normal sized disks (20 GB or larger)
# Cluster level list of directories to use for storage. These values will be set for all nodes that have no `directories` set.
#    directories:
#    - path: /rook/storage-dir
# Individual nodes and their config can be specified as well, but 'useAllNodes' above must be set to false. Then, only the named
# nodes below will be used as storage resources.  Each node's 'name' field should match their 'kubernetes.io/hostname' label.
#    nodes:
#    - name: "172.17.4.101"
#      directories: # specific directories to use for storage can be specified for each node
#      - path: "/rook/storage-dir"
# you can override the cluster wide resource requests/limits per node, but only
# when using `useAllNodes: false`!
#      resources:
#        limits:
#          cpu: "500m"
#          memory: "1024Mi"
#        requests:
#          cpu: "500m"
#          memory: "1024Mi"
#    - name: "172.17.4.201"
#      devices: # specific devices to use for storage can be specified for each node
#      - name: "sdb"
#      - name: "sdc"
#      storeConfig: # configuration can be specified at the node level which overrides the cluster level config
#        storeType: bluestore
#    - name: "172.17.4.301"
#      deviceFilter: "^sd."
pools:
  - name: replicapool
    storageClass:
      enabled: true
      default: false
    spec:
      # For a pool based on raw copies, specify the number of copies. A size of 1 indicates no redundancy.
      replicated:
        size: 1
      # For an erasure-coded pool, comment out the replicated size above and uncomment the following settings.
      # Make sure you have enough OSDs to support the replica size or sum of the erasure coding and data chunks.
      #erasureCoded:
      #  dataChunks: 2
      #  codingChunks: 1
 
# Allows Ceph settings to be overridden
# WARNING: Modify Ceph settings carefully. You are leaving the sandbox tested by Rook. Changing the settings could result in unhealthy daemons or even data loss if used incorrectly.
# rookConfigOverride: |
#   [global]
#     osd crush update on start = false
#     osd pool default size = 2
